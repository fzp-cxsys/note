<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>


### 排序的等价命题

给出一个数组

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|6|7|8|9|10|
|unsorted|6|1|2|7|9|3|4|5|10|8|

观察上面的两个数组的每一个元素，你会发现经过排序的（以有小到大的顺序为例）数组的每个元素`array(i)`左边的所有元素均小于`array(i)`，右边的所有元素均大于`array(i)`。

这个命题反过来同样成立，如果一个数组的每个元素`array(i)`左边的所有元素均小于`array(i)`，右边的所有元素均大于`array(i)`，那么它就是有序的。

假设某数组中的元素`x`左边的所有元素均小于`x`，右边的所有元素均大于`x`，那么`x`就被称为这个数组的_关键值x_，或者称为_第k大的数_，`k`为`x`在数组中的位置。

现在排序的问题就可以被转化为寻找一个数组的所有`关键值x`的位置`k`。

### 快速排序计算方法

首先随机从数组中选择了一个数`x`，然后寻找它作为_关键值x_的位置k，一般为了实现简单都会选择第一个或最后一个元素。这个过程可以成为一趟快速排序，下面我演示一下一趟快速排序。

给定`i,j,x`，`i`为数组的起始位置，`j`为数组的结束位置，`x`为一个特殊值`null`。

**第一步**，将`array(i)`和`x`互换

- `i=0,j=9,x=6,array(i)=null`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|**_null_**|1|2|7|9|3|4|5|10|8|

**第二步**，将`j`向前移动，并比较`array(j)`和`x`的值，当发现小于`x`的`array(j)`时，将`array(j)`和`array(i)`互换

- `i=0,j=7,x=6,array(i)=5,array(j)=null`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|**_5_**|1|2|7|9|3|4|**_null_**|10|8|

**第三步**，将`i`向后移动，并比较`array(i)`和`x`的值，当发现大于`x`的`array(i)`时,将`array(j)`和`array(i)`互换

- `i=3,j=7,x=6,array(i)=null,array(j)=7`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|**_null_**|9|3|4|**_7_**|10|8|

**第四步**，重复二到三步，直到`i=j`

- `i=3,j=6,x=6,array(i)=4,array(j)=null`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|**_4_**|9|3|**_null_**|7|10|8|

- `i=4,j=6,x=6,array(i)=null,array(j)=9`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|4|**_null_**|3|**_9_**|7|10|8|

- `i=4,j=5,x=6,array(i)=3,array(j)=null`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|4|**_3_**|**_null_**|9|7|10|8|

- `i=j=5,x=6,array(i)=array(j)=null`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|4|3|**_null_**|9|7|10|8|

**第四步**，将`x`和`array(i)`互换

- `i=j=5,x=null,array(i)=array(j)=6`

|index|0|1|2|3|4|5|6|7|8|9|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|sorted|1|2|3|4|5|**_6_**|7|8|9|10|
|unsorted|5|1|2|4|3|**_6_**|9|7|10|8|

至此，我们完成了一趟快速排序，为`array(1)`找到了它的位置`k=5`,回顾一下整个过程，我们可以描述为“挖坑-填坑”，首先我们选择将`array(1)`挖走并交给`x`，然后开始寻找`x`应处的位置（这个位置左边的元素都小于`x`，右边的元素都大于`x`），然后开始从数组两端扫描数组（注意要选择“坑”的反方向扫描）。当“坑”左边的元素都满足要求（即都小于`x`）时，我们称其在左端，反之称其为在右端。“坑”在左端时，我们要从右端选择小于`x`的数来“填坑”；“坑”在右端时，我们要从左端选择大于`x`的数来“填坑”。当“坑”即处于左端也处于右端时，说明它左右均满足要求，也就是它到了_关键值x_的位置，现在将`x`拿来填坑。

一趟快速排序还原一个_关键值_的位置，这个_关键值_将数组分为左右两个，对这个数组递归的进行还原_关键值_的位置过程就完成了整个快速排序。

### 快速排序的时间复杂度

#### 最坏时间复杂度

因为每趟快速排序得到的_关键值_越靠近中位数（），递归次数越少，所以最坏情况下，每趟快速排序都将长度为n的数组分为一个长度为0每趟快速排序都将长度为n的数组分为一个长度为0和长度为n-1的数组，此时时间复杂度为`O($\Phi$)`
